==============================================================================
Colorizer                                                            *colorizer*

                                                                *colorizer.nvim*
Requires Neovim >= 0.10.0 and `set termguicolors`

Highlights terminal CSI ANSI color codes.

Usage: Establish the autocmd to highlight all filetypes.

>lua
  require("colorizer").setup()
<

Highlight using all css highlight modes in every filetype

>lua
  require("colorizer").setup({ user_default_options = { css = true } })
<

New structured options format:

>lua
  require("colorizer").setup({ options = { parsers = { css = true } } })
<

USE WITH COMMANDS ~

  `:ColorizerAttachToBuffer`
      Attach to the current buffer and start continuously highlighting
      matched color names and codes.
      If the buffer was already attached(i.e. being highlighted), the
      settings will be reloaded. This is useful for reloading settings for
      just one buffer.

  `:ColorizerDetachFromBuffer`
      Stop highlighting the current buffer (detach).

  `:ColorizerReloadAllBuffers`
      Reload all buffers that are being highlighted currently.
      Calls ColorizerAttachToBuffer on every buffer.

  `:ColorizerToggle`
      Toggle highlighting of the current buffer.

USE WITH LUA ~

ATTACH
  Accepts buffer number (0 or nil for current) and an option
  table of user_default_options from `setup`.  Option table can be nil
  which defaults to setup options.

>lua
  -- Attach to current buffer with local options:
  require("colorizer").attach_to_buffer(0, {
    mode = "background",
    css = false,
  })

  -- Attach with new format options:
  require("colorizer").attach_to_buffer(0, {
    parsers = { css = true },
    display = { mode = "foreground" },
  })

  -- Attach to current buffer with setup options:
  require("colorizer").attach_to_buffer()
<

DETACH

>lua
  -- Detach from current buffer:
  require("colorizer").detach_from_buffer(0)
  require("colorizer").detach_from_buffer()

  -- Detach from buffer with id 22:
  require("colorizer").detach_from_buffer(22)
<


                                                         *colorizer.rehighlight*
M.rehighlight({bufnr}, {opts}, {buf_local_opts}, {hl_opts})
     Rehighlight the buffer if colorizer is active

    Parameters: ~
        {bufnr}           (number)     Buffer number (0 for current)
        {opts}            (table)      Options (new format)
        {buf_local_opts}  (table|nil)  Buffer local options
        {hl_opts}         (table|nil)  Highlighting options
                                        - use_local_lines: boolean: Use `buf_local_opts` __startline and __endline for lines

    Returns: ~
        (table)  settings table to use when cleaning up buffer state in `colorizer.detach_from_buffer`
                  - ns_id number: Table of namespace ids to clear
                  - functions function: Table of detach functions to call


M.get_attached_bufnr({bufnr})                     *colorizer.get_attached_bufnr*
    Get attached bufnr

    Parameters: ~
        {bufnr}  (number|nil)  buffer number (0 for current)

    Returns: ~
        (number)  attached bufnr. Returns -1 if buffer is not attached to colorizer.

    See: ~
        |colorizer.buffer.highlight|


M.is_buffer_attached({bufnr})                     *colorizer.is_buffer_attached*
    Check if buffer is attached to colorizer

    Parameters: ~
        {bufnr}  (number|nil)  buffer number (0 for current)

    Returns: ~
        (boolean)  `true` if buffer is attached to colorizer.


M.reload_all_buffers()                            *colorizer.reload_all_buffers*
     Reload all of the currently active highlighted buffers.


M.reload_on_save({pattern})                           *colorizer.reload_on_save*
     Reload file on save; used for dev, to edit expect.txt and apply highlights from returned setup table

    Parameters: ~
        {pattern}  (string)  pattern to match file name


                                                    *colorizer.attach_to_buffer*
M.attach_to_buffer({bufnr}, {opts}, {bo_type})
    Attach to a buffer and continuously highlight changes.

    Parameters: ~
        {bufnr}    (number|nil)                buffer number (0 for current)
        {opts}     (table|nil)                 Options (new format or legacy `user_default_options`)
        {bo_type}  ("buftype"|"filetype"|nil)  The type of buffer option


M.detach_from_buffer({bufnr})                     *colorizer.detach_from_buffer*
     Stop highlighting the current buffer.

    Parameters: ~
        {bufnr}  (number|nil)  buffer number (0 for current)

    Returns: ~
        (number)  -1 if buffer is not attached, otherwise returns bufnr


M.setup({opts})                                                *colorizer.setup*
    Setup colorizer with user options

    Parameters: ~
        {opts}  (table|nil)  User provided options
                              `require("colorizer").setup()`

    See: ~
        |colorizer.config|


M.clear_highlight_cache()                      *colorizer.clear_highlight_cache*
     Clears the highlight cache and reloads all buffers.


==============================================================================
Configuration                                                 *colorizer.config*

Provides configuration options and utilities for setting up colorizer.

Colorizer supports two configuration formats:

1. **New structured format** (recommended): Uses the `options` key with
   logically grouped settings under `parsers`, `display`, and `hooks`.

2. **Legacy flat format**: Uses the `user_default_options` key with flat
   keys like `RGB`, `RRGGBB`, `rgb_fn`, `mode`, etc. This format is
   automatically translated to the new format and will continue to work.

NEW FORMAT EXAMPLE ~

>lua
  require("colorizer").setup({
    options = {
      parsers = {
        css = true,  -- preset: enables names, hex, rgb, hsl, oklch
        tailwind = { enable = true, mode = "normal" },
      },
      display = {
        mode = "virtualtext",
        virtualtext = { position = "after" },
      },
    },
  })
<

LEGACY FORMAT EXAMPLE ~

>lua
  require("colorizer").setup({
    user_default_options = {
      css = true,
      tailwind = "normal",
      mode = "virtualtext",
      virtualtext_inline = "after",
    },
  })
<

PRESETS ~

  `parsers.css = true` enables: names, hex (all), rgb, hsl, oklch
  `parsers.css_fn = true` enables: rgb, hsl, oklch

  Individual settings always override presets:
>lua
  parsers = { css = true, rgb = { enable = false } }
  -- rgb is disabled despite css preset
<

CUSTOM PARSERS ~

  Register custom parsers via `parsers.custom`:
>lua
  parsers = {
    custom = {
      {
        name = "my_parser",
        prefixes = { "Color." },
        parse = function(ctx)
          -- return length, rgb_hex or nil
        end,
      },
    },
  }
<


colorizer.NewOptions                                      *colorizer.NewOptions*
     Default options in the new structured format.

     The `options` table is organized into logical groups:
     - `parsers`: Which color formats to detect
     - `display`: How to render detected colors
     - `hooks`: Functions to customize behavior
     - `always_update`: Whether to update unfocused buffers


    Fields: ~
        {parsers}        (colorizer.ParsersOptions)  Parser configuration
        {display}        (colorizer.DisplayOptions)  Display configuration
        {hooks}          (colorizer.Hooks)           Hook functions
        {always_update}  (boolean)                   Update color values even if buffer is not focused


colorizer.ParsersOptions                              *colorizer.ParsersOptions*

    Fields: ~
        {css}       (boolean)                      Preset: enables names, hex (all), rgb, hsl, oklch. Individual settings override.
        {css_fn}    (boolean)                      Preset: enables rgb, hsl, oklch. Individual settings override.
        {names}     (colorizer.ParsersNames)       Named color options
        {hex}       (colorizer.ParsersHex)         Hex color options
        {rgb}       (colorizer.ParsersSimple)      rgb()/rgba() function parser
        {hsl}       (colorizer.ParsersSimple)      hsl()/hsla() function parser
        {oklch}     (colorizer.ParsersSimple)      oklch() function parser
        {tailwind}  (colorizer.ParsersTailwind)    Tailwind CSS color options
        {sass}      (colorizer.ParsersSass)        Sass variable color options
        {xterm}     (colorizer.ParsersSimple)      xterm 256-color code parser
        {custom}    (colorizer.CustomParserDef[])  List of custom parser definitions


colorizer.ParsersNames                                  *colorizer.ParsersNames*

    Fields: ~
        {enable}        (boolean)               Enable named colors (e.g. "Blue", "red")
        {lowercase}     (boolean)               Match lowercase names (e.g. "blue")
        {camelcase}     (boolean)               Match camelCase names (e.g. "LightBlue")
        {uppercase}     (boolean)               Match UPPERCASE names (e.g. "BLUE")
        {strip_digits}  (boolean)               Ignore names with digits (e.g. skip "blue3")
        {custom}        (table|function|false)  Custom name-to-RGB mappings. Table of `{name = "#rrggbb"}` or function returning one.


colorizer.ParsersHex                                      *colorizer.ParsersHex*

    Fields: ~
        {enable}    (boolean)  Master switch for all hex formats
        {rgb}       (boolean)  #RGB (3-digit)
        {rgba}      (boolean)  #RGBA (4-digit)
        {rrggbb}    (boolean)  #RRGGBB (6-digit)
        {rrggbbaa}  (boolean)  #RRGGBBAA (8-digit)
        {aarrggbb}  (boolean)  0xAARRGGBB


colorizer.ParsersSimple                                *colorizer.ParsersSimple*

    Fields: ~
        {enable}  (boolean)  Enable this parser


colorizer.ParsersTailwind                            *colorizer.ParsersTailwind*

    Fields: ~
        {enable}        (boolean)                Enable Tailwind CSS colors
        {mode}          ("normal"|"lsp"|"both")  "normal" parses names, "lsp" uses LSP, "both" combines
        {update_names}  (boolean)                Update tailwind_names color mapping from LSP results


colorizer.ParsersSass                                    *colorizer.ParsersSass*

    Fields: ~
        {enable}   (boolean)  Enable Sass color variable parsing
        {parsers}  (table)    Parsers for sass color values (e.g. `{ css = true }`)


colorizer.DisplayOptions                              *colorizer.DisplayOptions*

    Fields: ~
        {mode}         ("background"|"foreground"|"virtualtext")  How to display detected colors
        {virtualtext}  (colorizer.DisplayVirtualtext)             Virtual text display settings


colorizer.DisplayVirtualtext                      *colorizer.DisplayVirtualtext*

    Fields: ~
        {char}      (string)                     Character used for virtual text (default "â– ")
        {position}  (false|"before"|"after")     Inline virtualtext position. `false` for end-of-line.
        {hl_mode}   ("background"|"foreground")  Highlight mode for virtual text


colorizer.UserDefaultOptions                      *colorizer.UserDefaultOptions*
     Default user options for colorizer.

     This table defines individual options and alias options, allowing configuration of
     colorizer's behavior for different color formats (e.g., `#RGB`, `#RRGGBB`, `#AARRGGBB`, etc.).

     Individual Options: Options like `names`, `RGB`, `RRGGBB`, `RRGGBBAA`, `hsl_fn`, `rgb_fn`,
     `oklch_fn`, `AARRGGBB`, `tailwind`, and `sass` can be enabled or disabled independently.

     Alias Options: `css` and `css_fn` enable multiple options at once.
       - `css_fn = true` enables `hsl_fn`, `rgb_fn`, and `oklch_fn`.
       - `css = true` enables `names`, `RGB`, `RRGGBB`, `RRGGBBAA`, `hsl_fn`, `rgb_fn`, and `oklch_fn`.

     Option Priority: Individual options have higher priority than aliases.
     If both `css` and `css_fn` are true, `css_fn` has more priority over `css`.

    Fields: ~
        {names}               (boolean)                                  Enables named colors (e.g., "Blue").
        {names_opts}          (colorizer.NamesOpts)                      Names options for customizing casing, digit stripping, etc
        {names_custom}        (table|function|false)                     Custom color name to RGB value mappings. Should return a table of color names to RGB value pairs.
        {RGB}                 (boolean)                                  Enables `#RGB` hex codes.
        {RGBA}                (boolean)                                  Enables `#RGBA` hex codes.
        {RRGGBB}              (boolean)                                  Enables `#RRGGBB` hex codes.
        {RRGGBBAA}            (boolean)                                  Enables `#RRGGBBAA` hex codes.
        {AARRGGBB}            (boolean)                                  Enables `0xAARRGGBB` hex codes.
        {rgb_fn}              (boolean)                                  Enables CSS `rgb()` and `rgba()` functions.
        {hsl_fn}              (boolean)                                  Enables CSS `hsl()` and `hsla()` functions.
        {oklch_fn}            (boolean)                                  Enables CSS `oklch()` function.
        {css}                 (boolean)                                  Enables all CSS features (`rgb_fn`, `hsl_fn`, `oklch_fn`, `names`, `RGB`, `RRGGBB`).
        {css_fn}              (boolean)                                  Enables all CSS functions (`rgb_fn`, `hsl_fn`, `oklch_fn`).
        {tailwind}            (boolean|string)                           Enables Tailwind CSS colors (e.g., `"normal"`, `"lsp"`, `"both"`).
        {tailwind_opts}       (colorizer.TailwindOpts)                   Tailwind options for updating names cache, etc
        {sass}                (colorizer.SassOpts)                       Sass color configuration (`enable` flag and `parsers`).
        {mode}                ("background"|"foreground"|"virtualtext")  Display mode
        {virtualtext}         (string)                                   Character used for virtual text display.
        {virtualtext_inline}  (boolean|"before"|"after")                 Shows virtual text inline with color.
        {virtualtext_mode}    ("background"|"foreground")                Mode for virtual text display.
        {always_update}       (boolean)                                  Always update color values, even if buffer is not focused.
        {hooks}               (colorizer.Hooks)                          Table of hook functions
        {xterm}               (boolean)                                  Enables xterm 256-color codes (#xNN, \e[38;5;NNNm)


colorizer.NamesOpts                                        *colorizer.NamesOpts*

    Fields: ~
        {lowercase}     (boolean)  Converts color names to lowercase.
        {camelcase}     (boolean)  Converts color names to camelCase.
        {uppercase}     (boolean)  Converts color names to uppercase.
        {strip_digits}  (boolean)  Removes digits from color names.


colorizer.TailwindOpts                                  *colorizer.TailwindOpts*

    Fields: ~
        {update_names}  (boolean)  Updates Tailwind "normal" names cache from LSP results.


colorizer.SassOpts                                          *colorizer.SassOpts*

    Fields: ~
        {enable}   (boolean)  Enables Sass color parsing.
        {parsers}  (table)    A list of parsers to use, typically includes "css".


colorizer.Hooks                                                *colorizer.Hooks*

    Fields: ~
        {disable_line_highlight}  (function|false)  Returns boolean which controls if line should be parsed for highlights.


colorizer.CustomParserDef                            *colorizer.CustomParserDef*

    Fields: ~
        {name}           (string)                             unique identifier
        {prefixes?}      (string[])                           trie prefixes, e.g. {"color("}
        {prefix_bytes?}  (number[])                           raw byte triggers, e.g. {0x23} for '#'
        {parse}          (fun(ctx:colorizer.ParserContext):)


colorizer.ParserContext                                *colorizer.ParserContext*

    Fields: ~
        {line}         (string)  current line text
        {col}          (number)  1-indexed column position
        {bufnr}        (number)
        {line_nr}      (number)  0-indexed line number
        {opts}         (table)   full resolved options for this buffer
        {parser_opts}  (table)   this parser's config subtable
        {state}        (table)   per-buffer persistent state


colorizer.Options                                            *colorizer.Options*
     Options for colorizer that were passed in to setup function.
     After setup(), `M.options.options` holds the canonical new-format config.
     `M.options.user_default_options` holds a backward-compatible flat view.

    Fields: ~
        {filetypes}             (table)                         File types to highlight
        {buftypes}              (table)                         Buffer types to highlight
        {user_commands}         (boolean|table)                 User commands to enable
        {lazy_load}             (boolean)                       Lazily schedule buffer highlighting
        {user_default_options}  (colorizer.UserDefaultOptions)  Legacy flat options (backward compat)
        {options}               (colorizer.NewOptions)          Canonical structured options
        {exclusions}            (table)                         Excluded filetypes/buftypes
        {all}                   (table)                         Whether all filetypes/buftypes are enabled


M.is_legacy_options({opts})                 *colorizer.config.is_legacy_options*
     Detect if options are in legacy (old flat) format.

    Parameters: ~
        {opts}  (table)  Options to check

    Returns: ~
        (boolean)  if options appear to be in legacy format


M.translate_options({old_opts})             *colorizer.config.translate_options*

    Parameters: ~
        {old_opts}  (table)  Legacy flat options

    Returns: ~
        (table)  new-format options


M.translate_filetypes({old_ft})           *colorizer.config.translate_filetypes*
     Translate old polymorphic filetypes/buftypes format to new structured format.

    Parameters: ~
        {old_ft}  (table)  Old format filetypes/buftypes

    Returns: ~
        (table)  format { enable, exclude, overrides }


M.apply_presets({user_parsers})                 *colorizer.config.apply_presets*

    Parameters: ~
        {user_parsers}  (table|nil)  The user's raw parsers config


M.validate_new_options({opts})           *colorizer.config.validate_new_options*
     Validate new-format options. Validates enums, processes names.custom, checks hook types.

    Parameters: ~
        {opts}  (table)  New-format options (fully merged with defaults)


M.as_flat({opts})                                     *colorizer.config.as_flat*

    Parameters: ~
        {opts}  (table)  New-format options

    Returns: ~
        (table)  flat options


M.resolve_options({opts}, {user_opts})        *colorizer.config.resolve_options*

    Parameters: ~
        {opts}       (table|nil)  Options in any format
        {user_opts}  (table|nil)  The raw user-provided options (before merge), for preset priority

    Returns: ~
        (table)  new-format options


M.expand_sass_parsers()                   *colorizer.config.expand_sass_parsers*


M.set_bo_value({bo_type}, {val}, {opts})         *colorizer.config.set_bo_value*
     Set options for a specific buffer or file type.

    Parameters: ~
        {bo_type}  ("buftype"|"filetype")  The type of buffer option
        {val}      (string)                The specific value to set.
        {opts}     (table)                 New-format options


M.apply_alias_options({ud_opts})          *colorizer.config.apply_alias_options*
     Parse and apply alias options to the user options (legacy format).

    Parameters: ~
        {ud_opts}  (table)  user_default_options

    Returns: ~
        (table)


colorizer.SetupOptions                                  *colorizer.SetupOptions*
     Configuration options for the `setup` function.
     Use `options` (new format) or `user_default_options` (legacy format), not both.

    Fields: ~
        {filetypes}             (table|nil)                         File types to highlight. Use `"*"` for all. Supports `"!name"` exclusions and `name = {opts}` overrides.
        {buftypes}              (table|nil)                         Buffer types to highlight. Same format as filetypes.
        {options}               (colorizer.NewOptions|nil)          Structured options (recommended). See |colorizer.NewOptions|.
        {user_default_options}  (colorizer.UserDefaultOptions|nil)  Legacy flat options. Deprecated in favor of `options`.
        {user_commands}         (boolean|table)                     Enable all or specific user commands.
        {lazy_load}             (boolean)                           Lazily schedule buffer highlighting setup function.


M.get_setup_options({opts})                 *colorizer.config.get_setup_options*

    Parameters: ~
        {opts}  (table|nil)  Configuration options for colorizer.

    Returns: ~
        (table)  settings after merging user and default options.


M.new_bo_options()                             *colorizer.config.new_bo_options*


                                               *colorizer.config.get_bo_options*
M.get_bo_options({bo_type}, {buftype}, {filetype})
     Retrieve options based on buffer type and file type. Prefer filetype.

    Parameters: ~
        {bo_type}   ("buftype"|"filetype")  The type of buffer option
        {buftype}   (string)                Buffer type.
        {filetype}  (string)                File type.

    Returns: ~
        (table|nil)


==============================================================================
Buffer                                                        *colorizer.buffer*

Provides highlighting functions for buffer.

M.reset_cache()                                   *colorizer.buffer.reset_cache*
     Clean the highlight cache


                                                *colorizer.buffer.add_highlight*
M.add_highlight({bufnr}, {ns_id}, {line_start}, {line_end}, {data}, {opts}, {hl_opts})
     Create highlight and set highlights

    Parameters: ~
        {bufnr}       (number)     Buffer number (0 for current)
        {ns_id}       (number)     Namespace id for which to create highlights
        {line_start}  (number)     Line_start should be 0-indexed
        {line_end}    (number)     Last line to highlight
        {data}        (table)      Table output of `parse_lines`
        {opts}        (table)      Options (new format or legacy `user_default_options`)
        {hl_opts}     (table|nil)  Highlight options:
                                    - tailwind_lsp boolean: Clear tailwind_names namespace when applying Tailwind LSP highlighting


                                                    *colorizer.buffer.highlight*
M.highlight({bufnr}, {ns_id}, {line_start}, {line_end}, {opts}, {buf_local_opts})

    Parameters: ~
        {bufnr}           (number)  Buffer number, 0 for current
        {ns_id}           (number)  Namespace id, default is "colorizer" created with vim.api.nvim_create_namespace
        {line_start}      (number)  line_start should be 0-indexed
        {line_end}        (number)  Last line to highlight
        {opts}            (table)   Options (new format or legacy `user_default_options`)
        {buf_local_opts}  (table)   Buffer local options

    Returns: ~
        (table)  settings table to use when cleaning up buffer state in `colorizer.detach_from_buffer`
                  - ns_id number: Table of namespace ids to clear
                  - functions function: Table of detach functions to call


                                                  *colorizer.buffer.parse_lines*
M.parse_lines({bufnr}, {lines}, {line_start}, {opts})

    Parameters: ~
        {bufnr}       (number)  Buffer number (0 for current)
        {lines}       (table)   Table of lines to parse
        {line_start}  (number)  Buffer line number to start highlighting
        {opts}        (table)   Options (new format or legacy `user_default_options`)

    Returns: ~
        (table|nil)


==============================================================================
Color Utilities                                                *colorizer.color*

Provides color conversion and utility functions for RGB and HSL values.

M.hsl_to_rgb()                                      *colorizer.color.hsl_to_rgb*
    @return number|nil,number|nil,number|nil


M.hue_to_rgb({p}, {q}, {t})                         *colorizer.color.hue_to_rgb*

    Parameters: ~
        {p}  (number)  A helper variable representing part of the lightness scale.
        {q}  (number)  Another helper variable based on saturation and lightness.
        {t}  (number)  Adjusted hue component to be converted to RGB.

    Returns: ~
        (number)  RGB component value, in the range [0, 1].


M.is_bright({r}, {g}, {b})                           *colorizer.color.is_bright*

    Parameters: ~
        {r}  (number)  Red component, in the range [0, 255].
        {g}  (number)  Green component, in the range [0, 255].
        {b}  (number)  Blue component, in the range [0, 255].
                       @return boolean `true` if the color is bright, `false` if it's dark.


M.oklch_to_rgb()                                  *colorizer.color.oklch_to_rgb*


==============================================================================
Constants                                                  *colorizer.constants*

This module provides constants that are required across the application.

==============================================================================
Matcher                                                      *colorizer.matcher*

Manages matching and parsing of color patterns in buffers.
This module provides functions for setting up and applying color parsers
for different color formats such as RGB, HSL, hexadecimal, and named colors.
It uses a trie-based structure to optimize prefix-based parsing.

                                     *colorizer.matcher.get_buffer_parser_state*
M.get_buffer_parser_state({bufnr}, {parser_name})
     Get or create per-buffer state for a custom parser

    Parameters: ~
        {bufnr}        (number)
        {parser_name}  (string)

    Returns: ~
        (table)


                                    *colorizer.matcher.init_buffer_parser_state*
M.init_buffer_parser_state({bufnr}, {custom_parsers})
     Initialize per-buffer state for custom parsers

    Parameters: ~
        {bufnr}           (number)
        {custom_parsers}  (table)   List of custom parser definitions


                                 *colorizer.matcher.cleanup_buffer_parser_state*
M.cleanup_buffer_parser_state({bufnr})
     Clean up per-buffer custom parser state

    Parameters: ~
        {bufnr}  (number)


M.reset_cache()                                  *colorizer.matcher.reset_cache*


M.make({opts})                                          *colorizer.matcher.make*

    Parameters: ~
        {opts}  (table)  New-format options (with opts.parsers) or legacy flat ud_opts

    Returns: ~
        (function|boolean)  which will just parse the line for enabled parsers


==============================================================================
Utilities                                                      *colorizer.utils*

Provides utility functions for color handling and file operations.
This module contains helper functions for checking byte categories, merging tables,
parsing colors, managing file watchers, and handling buffer lines.

M.rgb_to_hex({r}, {g}, {b})                         *colorizer.utils.rgb_to_hex*
     Returns HEX format from RGB values

    Parameters: ~
        {r}  (number)  Red value
        {g}  (number)  Green value
        {b}  (number)  Blue value


M.byte_is_alphanumeric({byte})            *colorizer.utils.byte_is_alphanumeric*
     Checks if a byte represents an alphanumeric character.

    Parameters: ~
        {byte}  (number)  The byte to check.
                          @return boolean `true` if the byte is alphanumeric, otherwise `false`.


M.byte_is_hex({byte})                              *colorizer.utils.byte_is_hex*
     Checks if a byte represents a hexadecimal character.

    Parameters: ~
        {byte}  (number)  The byte to check.
                          @return boolean `true` if the byte is hexadecimal, otherwise `false`.


M.get_non_alphanum_keys({tbl})           *colorizer.utils.get_non_alphanum_keys*
     Extract non-alphanumeric characters to add as a valid index in the Trie

    Parameters: ~
        {tbl}  (table)  The table to extract non-alphanumeric characters from.

    Returns: ~
        (string)  extracted non-alphanumeric characters.


                                    *colorizer.utils.add_additional_color_chars*
M.add_additional_color_chars({chars})
     Adds additional characters to the list of valid color characters.

    Parameters: ~
        {chars}  (string)  The additional characters to add.
                           @return boolean `true` if the characters were added, otherwise `false`.


M.byte_is_valid_color_char({byte})    *colorizer.utils.byte_is_valid_color_char*

    Parameters: ~
        {byte}  (number)  The byte to check.
                          @return boolean `true` if the byte is valid, otherwise `false`.


M.count({str}, {pattern})                                *colorizer.utils.count*
    Count the number of character in a string

    Parameters: ~
        {str}      (string)
        {pattern}  (string)

    Returns: ~
        (number)


M.get_last_modified({path})                  *colorizer.utils.get_last_modified*
     Get last modified time of a file

    Parameters: ~
        {path}  (string)  file path

    Returns: ~
        (number|nil)  time


M.parse_hex({byte})                                  *colorizer.utils.parse_hex*
     Parses a hexadecimal byte.

    Parameters: ~
        {byte}  (number)  The byte to parse.

    Returns: ~
        (number)  parsed hexadecimal value of the byte.


M.watch_file({path}, {callback}, {...})             *colorizer.utils.watch_file*
     Watch a file for changes and execute callback

    Parameters: ~
        {path}      (string)    File path
        {callback}  (function)  Callback to execute
        {...}       (table)     params for callback

    Returns: ~
        (uv_fs_event_t|nil)


M.bufme({bufnr})                                         *colorizer.utils.bufme*

    Parameters: ~
        {bufnr}  (number|nil)  The buffer number to validate.

    Returns: ~
        (number)  validated buffer number.


M.visible_line_range({bufnr})               *colorizer.utils.visible_line_range*
     Returns range of visible lines

    Parameters: ~
        {bufnr}  (number)  Buffer number
                           @return number, number Start (0-index) and end (exclusive) range of lines in viewport


M.log_message()                                    *colorizer.utils.log_message*


M.hash_table({tbl})                                 *colorizer.utils.hash_table*
     Returns sha256 hash of lua table

    Parameters: ~
        {tbl}  (table)  Table to be hashed


==============================================================================
User Commands                                               *colorizer.usercmds*

This module provides functions for creating user commands for the Colorizer plugin in Neovim.
It allows the creation of commands to attach, detach, reload, and toggle the Colorizer functionality on buffers.
Available commands are:
- `ColorizerAttachToBuffer`: Attaches Colorizer to the current buffer
- `ColorizerDetachFromBuffer`: Detaches Colorizer from the current buffer
- `ColorizerReloadAllBuffers`: Reloads Colorizer for all buffers
- `ColorizerToggle`: Toggles Colorizer attachment to the buffer

M.make({cmds})                                         *colorizer.usercmds.make*

    Parameters: ~
        {cmds}  (table|boolean)  A list of command names to create or `true` to create all available commands


==============================================================================
Sass                                                            *colorizer.sass*

Manages Sass variable parsing and color detection for buffers.
This module handles the parsing of Sass color variables, managing import statements,
and watching files for updates to Sass variable definitions.
It supports recursive Sass imports, resolving color values for each variable, and caching color definitions.

M.cleanup({bufnr})                                      *colorizer.sass.cleanup*
     Cleanup sass variables and watch handlers

    Parameters: ~
        {bufnr}  (number)


M.parser({line}, {i}, {bufnr})                           *colorizer.sass.parser*

    Parameters: ~
        {line}   (string)  Line to parse
        {i}      (number)  Index of line from where to start parsing
        {bufnr}  (number)  Buffer number
                           @return number|nil, string|nil


                                               *colorizer.sass.update_variables*
M.update_variables({bufnr}, {line_start}, {line_end}, {lines}, {color_parser}, {opts}, {buf_local_opts})

    Parameters: ~
        {bufnr}           (number)            Buffer number
        {line_start}      (number)
        {line_end}        (number)
        {lines}           (table|nil)
        {color_parser}    (function|boolean)
        {opts}            (table)             Options (new format or legacy)
        {buf_local_opts}  (table|nil)         Buffer local options


==============================================================================
Tailwind                                                    *colorizer.tailwind*

Handles Tailwind CSS color highlighting within buffers.
This module integrates with the Tailwind CSS Language Server Protocol (LSP) to retrieve and apply
color highlights for Tailwind classes in a buffer. It manages LSP attachment, autocmds for color updates,
and maintains state for efficient Tailwind highlighting.

M.cleanup({bufnr})                                  *colorizer.tailwind.cleanup*
     Cleanup tailwind variables and autocmd

    Parameters: ~
        {bufnr}  (number|nil)  buffer number (0 for current)


                                              *colorizer.tailwind.lsp_highlight*
M.lsp_highlight({bufnr}, {opts}, {buf_local_opts}, {add_highlight}, {on_detach}, {line_start}, {line_end})
     Highlight buffer using values returned by tailwindcss

    Parameters: ~
        {bufnr}           (number)    Buffer number (0 for current)
        {opts}            (table)     Options (new format or legacy)
        {buf_local_opts}  (table)     Buffer local options
        {add_highlight}   (function)  Function to add highlights
        {on_detach}       (function)  Function to call when LSP is detached
        {line_start}      (number)    Start line
        {line_end}        (number)    End line

    Returns: ~
        (boolean|nil)


==============================================================================
ARGB Hex Parser                                      *colorizer.parser.argb_hex*

This module provides a parser for extracting `0xAARRGGBB` hexadecimal color values and converting them to RGB hex.
This format is commonly used in Android apps for color values, where the color includes an alpha (transparency) component.
The function parses the color, applies the alpha value to each RGB channel, and returns the resulting RGB hex string.

M.parser({line}, {i})                         *colorizer.parser.argb_hex.parser*

    Parameters: ~
        {line}  (string)  The line of text to parse
        {i}     (number)  The starting index within the line where parsing should begin

    Returns: ~
        (number|nil)  end index of the parsed hex value within the line, or `nil` if parsing failed
        (string|nil)  RGB hexadecimal color (e.g., "ff0000" for red), or `nil` if parsing failed


==============================================================================
HSL Parser                                                *colorizer.parser.hsl*

This module provides a parser for identifying and converting `hsl()` and `hsla()` CSS functions to RGB hexadecimal format.
It supports various CSS color value formats, including degrees (`deg`), turns (`turn`), percentages, and alpha transparency.
This function is useful for syntax highlighting or color recognition in a text editor.

M.parser({line}, {i}, {opts})                      *colorizer.parser.hsl.parser*

    Parameters: ~
        {line}  (string)  The line of text to parse
        {i}     (number)  The starting index within the line where parsing should begin
        {opts}  (table)   Parsing options, including:
                            - `prefix` (string): "hsl" or "hsla" to specify the CSS function type.

    Returns: ~
        (number|nil)  end index of the parsed `hsl/hsla` function within the line, or `nil` if no match was found.
        (string|nil)  RGB hexadecimal color (e.g., "ff0000" for red), or `nil` if parsing failed


==============================================================================
Names Parser                                            *colorizer.parser.names*

This module provides a parser that identifies named colors from a given line of text.
It uses a Trie structure for efficient prefix-based matching of color names to #rrggbb values.
The module supports multiple namespaces, enabling flexible configuration and handling of
different types of color names (e.g., lowercase, uppercase, camelcase, custom names, Tailwind names).

Namespaces:
- lowercase: Contains color names converted to lowercase (e.g., "red" -> "#ff0000").
- uppercase: Contains color names converted to uppercase (e.g., "RED" -> "#ff0000").
- camelcase: Contains color names in camel case (e.g., "LightBlue" -> "#add8e6").
- tailwind_names: Contains color names based on TailwindCSS conventions, including prefixes.
- names_custom: Contains user-defined color names, either as a table or a function returning a table.

The parser dynamically populates the Trie and namespaces based on the provided options.
Unused namespaces are left empty, avoiding unnecessary memory usage. Color name matching respects
the configured namespaces and user-defined preferences, such as whether to strip digits.

M.reset_cache()                             *colorizer.parser.names.reset_cache*


                                           *colorizer.parser.names.update_color*
M.update_color({name}, {hex}, {namespace})
     Updates the color value for a given color name.

    Parameters: ~
        {name}       (string)  The color name.
        {hex}        (string)  The color value in hex format.
        {namespace}  (string)  The color map namespace.


M.parser({line}, {i}, {m_opts})                  *colorizer.parser.names.parser*
     Parses a line to identify color names.

    Parameters: ~
        {line}    (string)  The text line to parse.
        {i}       (number)  The index to start parsing from.
        {m_opts}  (table)   Matcher opts
                            @return number|nil, string|nil Length of match and hex value if found.


==============================================================================
OKLCH Parser                                            *colorizer.parser.oklch*

This module provides a parser for identifying and converting `oklch()` CSS functions to RGB hexadecimal format.
OKLCH is a perceptual color space that provides better uniformity than HSL.
It supports lightness as both decimal (0-1) and percentage (0-100%),
chroma values, hue in degrees, and optional alpha transparency.
This function is useful for syntax highlighting or color recognition in a text editor.

M.parser({line}, {i}, {_})                       *colorizer.parser.oklch.parser*

    Parameters: ~
        {line}  (string)  The line of text to parse
        {i}     (number)  The starting index within the line where parsing should begin
        {_}     (table)   Parsing options (unused, included for API consistency)

    Returns: ~
        (number|nil)  end index of the parsed `oklch` function within the line, or `nil` if no match was found.
        (string|nil)  RGB hexadecimal color (e.g., "ff0000" for red), or `nil` if parsing failed


==============================================================================
RGB Parser                                                *colorizer.parser.rgb*

This module provides a parser for identifying and converting `rgb()` and `rgba()` CSS functions to RGB hexadecimal format.
It supports decimal and percentage values for RGB channels, as well as an optional alpha (transparency) component.
The function can interpret a variety of CSS syntax variations, making it useful for syntax highlighting or color parsing.

M.parser()                                         *colorizer.parser.rgb.parser*

    Returns: ~
        (number|nil)  end index of the parsed `rgb/rgba` function within the line, or `nil` if parsing failed
        (string|nil)  RGB hexadecimal color (e.g., "ff0000" for red), or `nil` if parsing failed


==============================================================================
RGBA Hex Parser                                      *colorizer.parser.rgba_hex*

This module provides a parser for identifying and converting `#RRGGBBAA` hexadecimal color values to RGB hexadecimal format.
It is commonly used in Android apps for colors with an alpha (transparency) component.
The function reads the color, applies the alpha to each RGB channel, and returns the resulting RGB hex string.

M.parser({line}, {i}, {opts})                 *colorizer.parser.rgba_hex.parser*

    Parameters: ~
        {line}  (string)  The line of text to parse for the hex color
        {i}     (number)  The starting index within the line where parsing should begin
        {opts}  (table)   Options containing:
                           - `minlen` (number): Minimum length of the color string
                           - `maxlen` (number): Maximum length of the color string
                           - `valid_lengths` (table): Set of valid lengths (e.g., `{3, 4, 6, 8}`)

    Returns: ~
        (number|nil)  end index of the parsed hex color within the line, or `nil` if parsing failed
        (string|nil)  RGB hexadecimal color (e.g., "ff0000" for red), or `nil` if parsing failed


==============================================================================
Xterm Parser                                            *colorizer.parser.xterm*

This module provides a parser for identifying and converting xterm color codes to RGB hexadecimal format.
It supports both #xNN format (decimal, 0-255) and ANSI escape sequences \e[38;5;NNNm for xterm 256-color palette.
The function reads the color code and returns the corresponding RGB hex string from the xterm color palette.

M.parser({line}, {i})                            *colorizer.parser.xterm.parser*

    Parameters: ~
        {line}  (string)  The line of text to parse for xterm color codes
        {i}     (number)  The starting index within the line where parsing should begin

    Returns: ~
        (number|nil)  end index of the parsed xterm color code within the line, or `nil` if parsing failed
        (string|nil)  RGB hexadecimal color from the xterm palette, or `nil` if parsing failed


vim:tw=78:ts=8:noet:ft=help:norl:
